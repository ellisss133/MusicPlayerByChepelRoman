# Музыкальный плеер с использованием паттерна State

##  Постановка задачи

Разработать простой музыкальный плеер, который позволяет пользователю управлять воспроизведением музыкальных треков: запускать воспроизведение, ставить на паузу, останавливать и переключать на следующий трек. Приложение должно иметь графический интерфейс на базе Windows Forms и использовать объектно-ориентированный подход к управлению состояниями проигрывателя.

###  Прикладная проблема

В обычных реализациях медиаплееров логика управления воспроизведением часто усложняется многочисленными проверками состояний (например, if-else конструкциями для "играет", "пауза", "стоп"). Это усложняет поддержку и расширение кода.

Для решения этой проблемы используется поведенческий паттерн **State**, который позволяет организовать поведение проигрывателя в виде отдельных состояний и упростить добавление новых состояний и логики в будущем.

###  Основные функции плеера

- Воспроизведение MP3-треков из локальной папки `Tracks`
- Пауза с возможностью продолжения с текущей позиции
- Остановка воспроизведения
- Переключение на следующий трек
- Отображение текущего трека и состояния

##  Используемый паттерн: State

###  Что такое паттерн State?

Паттерн **State (Состояние)** — поведенческий шаблон проектирования, позволяющий объекту изменять своё поведение в зависимости от текущего состояния. Извне кажется, что объект меняет свой класс.

###  Цель применения паттерна

В приложении музыкального плеера состояние может быть:
- **Воспроизведение (Playing)**
- **Пауза (Paused)**
- **Остановлено (Stopped)**

Без паттерна это привело бы к множеству `if`-`else` или `switch`-конструкций внутри одного большого метода. Такой подход сложен в поддержке и масштабировании.

Применив паттерн **State**, мы вынесли поведение в отдельные классы-состояния, реализующие общий интерфейс `IPlayerState`. Это дало нам:
- Чистую и модульную архитектуру
- Простоту добавления новых состояний (например, "перемотка", "повтор")
- Уменьшение связности между логикой воспроизведения и состоянием плеера

###  Реализация

Каждое состояние (`PlayingState`, `PausedState`, `StoppedState`) реализует методы `Play()`, `Pause()`, `Stop()`, `Next()` по-своему. Объект `PlayerContext` делегирует вызовы текущему состоянию.

Смена состояний происходит через метод `SetState(newState)` внутри `PlayerContext`.

Это делает поведение проигрывателя гибким и расширяемым — без необходимости переписывать основной код.

##  Использование GitHub Flow

В процессе разработки проекта применялся **GitHub Flow**

### Основные этапы:

1. **Создание репозитория на GitHub**
   - Репозиторий с исходным кодом был размещён на GitHub.

2. **Работа с ветками**
   - Для каждой новой функции или исправления создавалась отдельная ветка:
     - `feature/state-pattern` — реализация паттерна State
     - `feature/naudio-support` — добавление поддержки MP3 через библиотеку NAudio

3. **Коммиты с понятными сообщениями**
   - Каждый логически завершённый шаг фиксировался коммитом с осмысленным сообщением:
     - `Add basic player UI`
     - `Implement State pattern for playback`

4. **Слияние через Pull Request**
   - После завершения работы над веткой, изменения объединялись в основную ветку `main` через Pull Request. Это позволяет удобно отслеживать историю изменений.

5. **Демонстрация через GitHub**
   - Проект доступен на GitHub с полным журналом изменений и версий.
